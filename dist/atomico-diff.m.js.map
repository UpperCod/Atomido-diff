{"version":3,"file":"atomico-diff.m.js","sources":["../src/constants.js","../src/dom.js","../src/vdom.js","../src/diff.js","../src/index.js"],"sourcesContent":["export const ELEMENT_PREFIX = \"element-\";\r\nexport const ELEMENT_OBSERVER = ELEMENT_PREFIX + \"observer\";\r\nexport const ELEMENT_COLLECT = ELEMENT_PREFIX + \"collect\";\r\nexport const ELEMENT_MASTER = ELEMENT_PREFIX + \"master\";\r\n","export function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n","import { ELEMENT_OBSERVER, ELEMENT_COLLECT } from \"./constants\";\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\n\r\nexport class VDom {\r\n    constructor(tag, props, children) {\r\n        this.tag = tag;\r\n        this.props = props || {};\r\n        this.children = children || [];\r\n        this.collect = this.props[ELEMENT_COLLECT] || false;\r\n    }\r\n    emit(type, arg) {\r\n        let observer = this.props[ELEMENT_OBSERVER];\r\n        if (typeof observer === \"function\") observer(type, arg);\r\n    }\r\n    clone(tag = this.tag, props = this.props, children = this.children) {\r\n        return new VDom(tag, props, children);\r\n    }\r\n}\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child) ? child : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","import { ELEMENT_MASTER, ELEMENT_PREFIX, ELEMENT_COLLECT } from \"./constants\";\r\nimport { remove, append, replace } from \"./dom\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport default function diff(parent, prevNode, next, slots = {}, isSvg) {\r\n    let prev = (prevNode && prevNode[ELEMENT_MASTER]) || new VDom(),\r\n        nextNode = prevNode,\r\n        nextMaster = next;\r\n\r\n    if (next) {\r\n        let isSlot = next.tag === \"slot\";\r\n\r\n        next = slot(next, slots);\r\n        prev = slot(prev, slots);\r\n\r\n        isSvg = isSvg || next.tag === \"svg\";\r\n\r\n        if (parent) {\r\n            if (prev.tag !== next.tag) {\r\n                nextNode = isDom(next.tag)\r\n                    ? next.tag\r\n                    : next.tag\r\n                        ? isSvg\r\n                            ? document.createElementNS(\r\n                                  \"http://www.w3.org/2000/svg\",\r\n                                  next.tag\r\n                              )\r\n                            : document.createElement(next.tag)\r\n                        : document.createTextNode(\"\");\r\n                if (prevNode) {\r\n                    replace(parent, nextNode, prevNode);\r\n                    while (!isSlot && !next.collect && prevNode.firstChild) {\r\n                        append(nextNode, prevNode.firstChild);\r\n                    }\r\n                } else {\r\n                    append(parent, nextNode);\r\n                }\r\n            }\r\n        }\r\n        if (nextNode.nodeType === 3) {\r\n            if (prev.children[0] !== next.children[0])\r\n                nextNode.textContent = next.children[0];\r\n        } else {\r\n            let props = diffProps(\r\n                nextNode,\r\n                next.tag === prev.tag ? prev.props : {},\r\n                next.props,\r\n                isSvg,\r\n                /**\r\n                 * It allows to obtain properties of the iteration of diff by properties\r\n                 */\r\n                next.collect,\r\n                /**\r\n                 * This allows not to delete the previous state and keep it in the next state\r\n                 */\r\n                parent && next.collect\r\n            );\r\n            if (next.collect) {\r\n                props.children = next.children.map(\r\n                    vdom => (vdom.tag ? vdom : vdom.children[0])\r\n                );\r\n                next.emit(ELEMENT_COLLECT, props);\r\n            } else {\r\n                if (!isSlot && nextNode) {\r\n                    let children = Array.from(nextNode.childNodes),\r\n                        length = Math.max(\r\n                            children.length,\r\n                            next.children.length\r\n                        );\r\n                    for (let i = 0; i < length; i++) {\r\n                        diff(\r\n                            nextNode,\r\n                            children[i],\r\n                            next.children[i],\r\n                            slots,\r\n                            isSvg\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (parent && prevNode) {\r\n            remove(parent, prevNode);\r\n        }\r\n    }\r\n    nextNode[ELEMENT_MASTER] = nextMaster;\r\n    return nextNode;\r\n}\r\n\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nfunction diffProps(node, prev, next, isSvg, collect, nextMerge) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        length = keys.length,\r\n        props = {};\r\n    for (let i = 0; i < length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (!prop.indexOf(ELEMENT_PREFIX) || (isSvg && prop === \"xmlns\"))\r\n            continue;\r\n        if (prev[prop] !== next[prop]) {\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n\r\n            let isFnNext = typeof next[prop] === \"function\",\r\n                isFnPrev = typeof prev[prop] === \"function\";\r\n\r\n            if (isFnNext || isFnPrev) {\r\n                if (isFnPrev) node.removeEventListener(prop, prev[prop]);\r\n                if (isFnNext) node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            let prevStyle = prev[prop] || {},\r\n                                nextStyle = next[prop];\r\n                            for (let prop in nextStyle) {\r\n                                if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                    if (prop[0] === \"-\") {\r\n                                        node.setProperty(prop, nextStyle[prop]);\r\n                                    } else {\r\n                                        node.style[prop] = nextStyle[prop];\r\n                                    }\r\n                                }\r\n                            }\r\n                            next[prop] = { ...prevStyle, ...nextStyle };\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    isSvg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                if (nextMerge) {\r\n                    next[prop] = prev[prop];\r\n                } else {\r\n                    node.removeAttribute(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        return vdom.clone(slots[vdom.props.name] || \"\");\r\n    }\r\n    return vdom;\r\n}\r\n","import diff from \"./diff\";\r\nimport { h } from \"./vdom\";\r\nimport { ELEMENT_OBSERVER, ELEMENT_COLLECT } from \"./constants\";\r\n\r\nexport default {\r\n    diff,\r\n    h,\r\n    ELEMENT_COLLECT,\r\n    ELEMENT_OBSERVER\r\n};\r\n"],"names":["ELEMENT_PREFIX","ELEMENT_OBSERVER","ELEMENT_COLLECT","ELEMENT_MASTER","root","parent","shadowRoot","remove","child","removeChild","append","appendChild","replace","newChild","oldChild","replaceChild","h","tag","props","children","VDom","concat","[object Object]","this","collect","type","arg","observer","isDom","nodeType","isVDom","value","merge","i","length","Array","isArray","push","diff","prevNode","next","slots","isSvg","prev","nextNode","nextMaster","isSlot","slot","document","createElementNS","createElement","createTextNode","firstChild","textContent","diffProps","map","vdom","emit","from","childNodes","Math","max","node","nextMerge","keys","Object","prop","indexOf","isFnNext","isFnPrev","removeEventListener","addEventListener","prevStyle","nextStyle","setProperty","style","cssText","setAttributeNS","setAttribute","removeAttribute","clone","name"],"mappings":"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"}