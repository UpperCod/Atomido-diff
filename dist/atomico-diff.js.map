{"version":3,"file":"atomico-diff.js","sources":["../src/constants.js","../src/dom.js","../src/vdom.js","../src/diff.js"],"sourcesContent":["export const ELEMENT_PREFIX = \"element-\";\r\nexport const ELEMENT_COLLECT = ELEMENT_PREFIX + \"collect\";\r\nexport const ELEMENT_MASTER = ELEMENT_PREFIX + \"master\";\r\nexport const ELEMENT_CONTEXT = ELEMENT_PREFIX + \"context\";\r\n","export function root(parent) {\r\n    return parent.shadowRoot || parent;\r\n}\r\nexport function remove(parent, child) {\r\n    root(parent).removeChild(child);\r\n}\r\n\r\nexport function append(parent, child) {\r\n    root(parent).appendChild(child);\r\n}\r\n\r\nexport function replace(parent, newChild, oldChild) {\r\n    root(parent).replaceChild(newChild, oldChild);\r\n}\r\n","/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n * @return {VDom}\r\n */\r\nexport function h(tag, props, ...children) {\r\n    return new VDom(tag, props, concat(children));\r\n}\r\n/**\r\n * Create an instance of a virtual node\r\n * @param {*} tag - be social to the tagName\r\n * @param {*} props - is associated with the attributes of the tag\r\n * @param  {...*} children - the children associated with the tag\r\n */\r\n\r\nexport class VDom {\r\n    constructor(tag, props, children) {\r\n        this.tag = tag;\r\n        this.props = props || {};\r\n        this.children = children || [];\r\n    }\r\n    clone(tag = this.tag, props = this.props, children = this.children) {\r\n        return new VDom(tag, { ...props }, children);\r\n    }\r\n}\r\nexport function isDom(tag) {\r\n    return tag !== null && typeof tag === \"object\" && tag.nodeType !== 11\r\n        ? true\r\n        : false;\r\n}\r\n/**\r\n *\r\n * @param {*} value\r\n * @return {Boolean}\r\n */\r\nexport function isVDom(value) {\r\n    return typeof value === \"object\" && value instanceof VDom;\r\n}\r\n/**\r\n * prepares the children associated with virtual dom, managing to simplify the algorithm of diff\r\n * @param {*} children - list of children associated with the virtual dom\r\n * @param {*} merge - array that concatenates all the children independent of the depth of the array\r\n * @return {Array}\r\n */\r\nexport function concat(children, merge = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        Array.isArray(child)\r\n            ? concat(child, merge)\r\n            : merge.push(\r\n                  isVDom(child) ? child : new VDom(\"\", {}, [child || \"\"])\r\n              );\r\n    }\r\n    return merge;\r\n}\r\n","import { ELEMENT_MASTER, ELEMENT_COLLECT, ELEMENT_CONTEXT } from \"./constants\";\r\nimport { remove, append, replace } from \"./dom\";\r\nimport { VDom, h, isDom } from \"./vdom\";\r\n/**\r\n * Analyze if prev Node has or does not have a state defined by the diff process,\r\n * this is left linked to the node to avoid its loss either by external editing.\r\n *\r\n * @param {HTMLELement} [parent] - If the father is defined, the remove function is activated,\r\n *                                 it allows to remove the nodes from the father\r\n * @param {HTMLELement} [prevNode] - Node that can possess the previous state\r\n * @param {Object} next - Next render state\r\n * @param {Object} slots - Group the slots to be retrieved by the special slot tag\r\n * @param {*} context - allows to share information within the children of the component\r\n * @param {Boolean} svg - define if the html element is a svg\r\n * @return {HTMLELement} - returns the current node.\r\n */\r\nexport function diff(parent, prevNode, next, slots = {}, context, isSvg) {\r\n    let prev = (prevNode && prevNode[ELEMENT_MASTER]) || new VDom(),\r\n        nextNode = prevNode,\r\n        nextMaster = next;\r\n\r\n    if (next) {\r\n        let isSlot = next.tag === \"slot\";\r\n\r\n        next = slot(next, slots);\r\n        prev = slot(prev, slots);\r\n\r\n        isSvg = isSvg || next.tag === \"svg\";\r\n\r\n        if (parent) {\r\n            if (prev.tag !== next.tag) {\r\n                nextNode = isDom(next.tag)\r\n                    ? next.tag\r\n                    : next.tag\r\n                        ? isSvg\r\n                            ? document.createElementNS(\r\n                                  \"http://www.w3.org/2000/svg\",\r\n                                  next.tag\r\n                              )\r\n                            : document.createElement(next.tag)\r\n                        : document.createTextNode(\"\");\r\n                if (prevNode) {\r\n                    replace(parent, nextNode, prevNode);\r\n                    while (!isSlot && !next.collect && prevNode.firstChild) {\r\n                        append(nextNode, prevNode.firstChild);\r\n                    }\r\n                } else {\r\n                    append(parent, nextNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextNode.nodeType === 3) {\r\n            if (prev.children[0] !== next.children[0])\r\n                nextNode.textContent = next.children[0];\r\n        } else {\r\n            if (nextNode && nextNode[ELEMENT_CONTEXT]) {\r\n                context = nextNode[ELEMENT_CONTEXT](context);\r\n            }\r\n            let collect = (parent && nextNode[ELEMENT_COLLECT]) || {},\r\n                props = diffProps(\r\n                    nextNode,\r\n                    next.tag === prev.tag ? prev.props : {},\r\n                    next.props,\r\n                    isSvg,\r\n                    /**\r\n                     * It allows to obtain properties of the iteration of diff by properties\r\n                     */\r\n                    collect.props\r\n                );\r\n            if (collect.handler) {\r\n                props.children = next.children.map(\r\n                    vdom => (vdom.tag ? vdom : vdom.children[0])\r\n                );\r\n                collect.handler(props);\r\n            } else {\r\n                if (!isSlot && nextNode) {\r\n                    let children = Array.from(\r\n                            (nextNode.shadowRoot || nextNode).childNodes\r\n                        ),\r\n                        length = Math.max(\r\n                            children.length,\r\n                            next.children.length\r\n                        );\r\n                    for (let i = 0; i < length; i++) {\r\n                        diff(\r\n                            nextNode,\r\n                            children[i],\r\n                            next.children[i],\r\n                            slots,\r\n                            context,\r\n                            isSvg\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (parent && prevNode) {\r\n            remove(parent, prevNode);\r\n        }\r\n    }\r\n    nextNode[ELEMENT_MASTER] = nextMaster;\r\n    return nextNode;\r\n}\r\n\r\nexport function Collect(node, props, handler) {\r\n    this.observer = node[ELEMENT_COLLECT] = { props, handler };\r\n}\r\n\r\nexport function Context(node, handler, prop = \"context\") {\r\n    node[ELEMENT_CONTEXT] = context => {\r\n        return (node[prop] = handler(context) || context);\r\n    };\r\n}\r\n\r\n/**\r\n * compares the attributes associated with the 2 render states\r\n * @param {HTMLELement} node\r\n * @param {Object} prev - properties that the node already has\r\n * @param {Object} next - object with the new properties to define the node\r\n * @param {Boolean} [svg] - define if the html element is a svg\r\n * @param {Object} [collect] -It allows to recover properties, avoiding in turn the analysis\r\n *                            of these on the node, these are returned in an object in association\r\n *                            with the key of the loop\r\n * @param {Boolean} [nextMerge] - it allows not to eliminate the properties of the previous state and add them to the next state\r\n * @return {Object} Collected properties\r\n */\r\nfunction diffProps(node, prev, next, isSvg, collect) {\r\n    // generates a list of the existing attributes in both versions\r\n    let keys = Object.keys(prev).concat(Object.keys(next)),\r\n        length = keys.length,\r\n        props = {};\r\n    for (let i = 0; i < length; i++) {\r\n        let prop = keys[i];\r\n\r\n        if (isSvg && prop === \"xmlns\") continue;\r\n        if (prev[prop] !== next[prop]) {\r\n            if (collect && collect.indexOf(prop) > -1) {\r\n                props[prop] = next[prop];\r\n                continue;\r\n            }\r\n\r\n            let isFnNext = typeof next[prop] === \"function\",\r\n                isFnPrev = typeof prev[prop] === \"function\";\r\n\r\n            if (isFnNext || isFnPrev) {\r\n                if (isFnPrev) node.removeEventListener(prop, prev[prop]);\r\n                if (isFnNext) node.addEventListener(prop, next[prop]);\r\n            } else if (prop in next) {\r\n                if ((prop in node && !isSvg) || (isSvg && prop === \"style\")) {\r\n                    if (prop === \"style\") {\r\n                        if (typeof next[prop] === \"object\") {\r\n                            let prevStyle = prev[prop] || {},\r\n                                nextStyle = next[prop];\r\n                            for (let prop in nextStyle) {\r\n                                if (prevStyle[prop] !== nextStyle[prop]) {\r\n                                    if (prop[0] === \"-\") {\r\n                                        node.setProperty(prop, nextStyle[prop]);\r\n                                    } else {\r\n                                        node.style[prop] = nextStyle[prop];\r\n                                    }\r\n                                }\r\n                            }\r\n                            next[prop] = { ...prevStyle, ...nextStyle };\r\n                        } else {\r\n                            node.style.cssText = next[prop];\r\n                        }\r\n                    } else {\r\n                        node[prop] = next[prop];\r\n                    }\r\n                } else {\r\n                    isSvg\r\n                        ? node.setAttributeNS(null, prop, next[prop])\r\n                        : node.setAttribute(prop, next[prop]);\r\n                }\r\n            } else {\r\n                if (collect) {\r\n                    next[prop] = prev[prop];\r\n                } else {\r\n                    node.removeAttribute(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return props;\r\n}\r\n/**\r\n *\r\n * @param {VDom} vdom - It allows to identify if this node requires the use of a slot\r\n * @param {Object} slots - Object that has living nodes associated by an index\r\n */\r\nfunction slot(vdom, slots) {\r\n    if (vdom.tag === \"slot\") {\r\n        vdom = vdom.clone(slots[vdom.props.name] || \"\");\r\n        delete vdom.props.name;\r\n        return vdom;\r\n    }\r\n    return vdom;\r\n}\r\n"],"names":[],"mappings":"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"}